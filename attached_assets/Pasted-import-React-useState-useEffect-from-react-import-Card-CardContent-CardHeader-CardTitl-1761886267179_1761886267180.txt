import React, { useState, useEffect } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Tabs, Tab, Box, Autocomplete, TextField, CircularProgress, FormControl, InputLabel, Select as MuiSelect, MenuItem, Button as MuiButton } from '@mui/material';
import { Badge } from '@/components/ui/badge';
import { useToast } from '@/hooks/use-toast';
import { useTickerDialog } from '@/components/TickerDetailsDialog';
import { TickerBadge } from '@/components/TickerBadge';
import { useQuery } from '@tanstack/react-query';
import { 
  Brain,
  TrendingUp, 
  DollarSign,
  BarChart3,
  Target,
  Sparkles,
  Zap,
  Activity,
  Search,
  Calendar
} from 'lucide-react';
import PredictiveDividendGrowthForecaster from '@/components/advanced/PredictiveDividendGrowthForecaster';
import AIInvestmentTrendPredictor from '@/components/advanced/AIInvestmentTrendPredictor';
import { ErrorState } from '@/components/ui/error-state';

interface PredictionData {
  symbol: string;
  prediction: string;
  confidence: number;
  timeframe: string;
  status: 'bullish' | 'bearish' | 'neutral';
  currentPrice?: number;
  predictedPrice?: number;
  dividendYield?: number;
}

export default function PredictionEngine() {
  const { toast } = useToast();
  const { handleTickerClick, TickerDialog } = useTickerDialog();
  const [tabValue, setTabValue] = useState(0);
  const [selectedSymbol, setSelectedSymbol] = useState('');
  const [selectedStock, setSelectedStock] = useState<{ symbol: string; name: string } | null>(null);
  const [stockOptions, setStockOptions] = useState<{ symbol: string; name: string }[]>([]);
  const [stockSearchLoading, setStockSearchLoading] = useState(false);
  const [predictionTimeframe, setPredictionTimeframe] = useState('12months');
  const [isGeneratingPrediction, setIsGeneratingPrediction] = useState(false);
  const [currentPrediction, setCurrentPrediction] = useState<PredictionData | null>(null);

  // Fetch stock predictions from database/API
  const { data: predictions = [], isLoading: predictionsLoading, isError: isPredictionsError, error: predictionsError, refetch: refetchPredictions } = useQuery({
    queryKey: ['/api/stock-predictions'],
    queryFn: async () => {
      const response = await fetch('/api/stock-predictions');
      if (!response.ok) throw new Error('Failed to fetch predictions');
      return response.json();
    }
  });

  // Fetch user's personal prediction history (authenticated endpoint)
  const { data: userPredictions = [], isLoading: userPredictionsLoading, isError: isUserPredictionsError, error: userPredictionsError, refetch: refetchUserPredictions } = useQuery({
    queryKey: ['/api/user-predictions'],
    queryFn: async () => {
      const response = await fetch('/api/user-predictions', {
        credentials: 'include' // Include session cookies
      });
      if (!response.ok) {
        // If not authenticated, return empty array
        if (response.status === 401) return [];
        throw new Error('Failed to fetch user predictions');
      }
      return response.json();
    }
  });

  // Fetch prediction analytics data
  const { data: predictionAnalytics, isLoading: analyticsLoading, isError: isAnalyticsError, error: analyticsError, refetch: refetchAnalytics } = useQuery({
    queryKey: ['/api/prediction-analytics'],
    queryFn: async () => {
      const response = await fetch('/api/prediction-analytics');
      if (!response.ok) throw new Error('Failed to fetch prediction analytics');
      return response.json();
    }
  });

  // Fetch market sentiment from HeyDividend API (keeping existing logic)
  const { data: marketStats, isLoading: statsLoading, isError: isStatsError, error: statsError, refetch: refetchStats } = useQuery({
    queryKey: ['/api/market-sentiment'],
    queryFn: async () => {
      const response = await fetch('/api/market-sentiment');
      if (!response.ok) throw new Error('Failed to fetch market sentiment');
      return response.json();
    }
  });

  // Search stocks using HeyDividend API
  const searchStocks = async (query: string) => {
    if (query.length < 2) {
      setStockOptions([]);
      return;
    }
    
    setStockSearchLoading(true);
    try {
      const response = await fetch(`/api/heydividend-stock-search?query=${encodeURIComponent(query)}`);
      if (response.ok) {
        const data = await response.json();
        setStockOptions(data.stocks || []);
      }
    } catch (error) {
      console.error('Error searching stocks:', error);
    } finally {
      setStockSearchLoading(false);
    }
  };

  // Generate prediction and save to database
  const generatePrediction = async () => {
    console.log('Generate prediction clicked', { selectedStock, selectedSymbol });
    
    if (!selectedStock && !selectedSymbol) {
      toast({ title: "Please select a stock symbol", variant: "destructive" });
      return;
    }

    const stockToPredict = selectedStock || { symbol: selectedSymbol, name: selectedSymbol };
    
    setIsGeneratingPrediction(true);
    try {
      const response = await fetch('/api/generate-prediction', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include', // Include session cookies for authentication
        body: JSON.stringify({ 
          symbol: stockToPredict.symbol, 
          timeframe: predictionTimeframe 
        })
      });

      if (!response.ok) throw new Error('Failed to generate prediction');
      
      const result = await response.json();
      
      // Create the prediction result to display from the database-saved prediction
      const newPrediction: PredictionData = {
        symbol: result.prediction.symbol,
        prediction: result.prediction.prediction,
        confidence: result.prediction.confidence,
        timeframe: result.prediction.timeframe,
        status: result.prediction.status,
        currentPrice: result.prediction.currentPrice,
        predictedPrice: result.prediction.predictedPrice,
        dividendYield: result.prediction.dividendYield
      };
      
      // Update the current prediction display
      setCurrentPrediction(newPrediction);
      
      // Refresh data from the database
      await Promise.all([
        refetchPredictions(), // Refresh global predictions
        refetchUserPredictions() // Refresh user's prediction history
      ]);
      
      toast({ 
        title: "Prediction Generated!", 
        description: `Analysis complete for ${stockToPredict.symbol} (${predictionTimeframe}). Saved to your prediction history!` 
      });
    } catch (error) {
      console.error('Prediction error:', error);
      toast({ 
        title: "Prediction Failed", 
        description: "Unable to generate prediction. Please try again.",
        variant: "destructive" 
      });
    } finally {
      setIsGeneratingPrediction(false);
    }
  };

  // Error handling for queries
  if (isPredictionsError) {
    return <ErrorState 
      title="Failed to load predictions"
      message={predictionsError?.message || "Unable to fetch stock predictions"}
      onRetry={() => refetchPredictions()}
    />
  }

  if (isUserPredictionsError) {
    return <ErrorState 
      title="Failed to load user predictions"
      message={userPredictionsError?.message || "Unable to fetch your prediction history"}
      onRetry={() => refetchUserPredictions()}
    />
  }

  if (isAnalyticsError) {
    return <ErrorState 
      title="Failed to load analytics"
      message={analyticsError?.message || "Unable to fetch prediction analytics data"}
      onRetry={() => refetchAnalytics()}
    />
  }

  if (isStatsError) {
    return <ErrorState 
      title="Failed to load market sentiment"
      message={statsError?.message || "Unable to fetch market sentiment data"}
      onRetry={() => refetchStats()}
    />
  }

  return (
    <div className="flex-1 overflow-auto">
      <div className="container mx-auto px-6 py-8">
        <div className="space-y-6">
          {/* Page Header */}
          <div className="mb-6">
              <h1 className="text-lg font-bold text-gray-900 dark:text-white mb-2">
                Prediction Engine
              </h1>
              <p className="text-gray-600 dark:text-gray-400">
                AI-powered dividend prediction and trend analysis for smarter investment decisions
              </p>
            </div>

            {/* Quick Stats Cards - Data from HeyDividend API */}
            <div className="grid grid-cols-1 md:grid-cols-4 gap-6 mb-8">
              <Card className="shadow-none border-0">
                <CardContent className="p-6">
                  <div className="flex items-center justify-between">
                    <div>
                      <p className="text-sm font-medium text-gray-600">Active Predictions</p>
                      <p className="text-lg font-bold text-gray-900">
                        {statsLoading ? '...' : (marketStats?.activePredictions || predictions.length)}
                      </p>
                    </div>
                    <Target className="w-8 h-8 text-blue-500" />
                  </div>
                  <p className="text-sm text-green-600 mt-2">
                    {statsLoading ? 'Loading...' : (marketStats?.weeklyChange || '+12% this week')}
                  </p>
                </CardContent>
              </Card>

              <Card className="shadow-none border-0">
                <CardContent className="p-6">
                  <div className="flex items-center justify-between">
                    <div>
                      <p className="text-sm font-medium text-gray-600">Accuracy Rate</p>
                      <p className="text-lg font-bold text-gray-900">
                        {statsLoading ? '...' : (marketStats?.accuracyRate || '94.2%')}
                      </p>
                    </div>
                    <Sparkles className="w-8 h-8 text-green-500" />
                  </div>
                  <p className="text-sm text-green-600 mt-2">
                    {statsLoading ? 'Loading...' : (marketStats?.accuracyTrend || 'Above 90% threshold')}
                  </p>
                </CardContent>
              </Card>

              <Card className="shadow-none border-0">
                <CardContent className="p-6">
                  <div className="flex items-center justify-between">
                    <div>
                      <p className="text-sm font-medium text-gray-600">Trend Alerts</p>
                      <p className="text-lg font-bold text-gray-900">
                        {statsLoading ? '...' : (marketStats?.trendAlerts || '8')}
                      </p>
                    </div>
                    <Activity className="w-8 h-8 text-orange-500" />
                  </div>
                  <p className="text-sm text-blue-600 mt-2">
                    {statsLoading ? 'Loading...' : (marketStats?.newAlertsToday || '3 new today')}
                  </p>
                </CardContent>
              </Card>

              <Card className="shadow-none border-0">
                <CardContent className="p-6">
                  <div className="flex items-center justify-between">
                    <div>
                      <p className="text-sm font-medium text-gray-600">Model Updates</p>
                      <p className="text-lg font-bold text-gray-900">
                        {statsLoading ? '...' : (marketStats?.updateFrequency || 'Daily')}
                      </p>
                    </div>
                    <Zap className="w-8 h-8 text-purple-500" />
                  </div>
                  <p className="text-sm text-gray-600 mt-2">
                    {statsLoading ? 'Loading...' : (marketStats?.lastUpdate || 'Last: 2 hours ago')}
                  </p>
                </CardContent>
              </Card>
            </div>

            {/* Prediction Controls with Tabs */}
            <Card className="mb-6 shadow-none border-0">
              <CardHeader>
                <CardTitle className="flex items-center text-base">
                  <Search className="w-5 h-5 mr-2" />
                  Prediction Controls
                </CardTitle>
              </CardHeader>
              <CardContent>
                <Box sx={{ width: '100%' }}>
                  <Tabs 
                    value={tabValue} 
                    onChange={(event, newValue) => setTabValue(newValue)}
                    variant="fullWidth"
                    sx={{
                      '& .MuiTabs-indicator': {
                        backgroundColor: '#005294',
                      },
                      '& .MuiTab-root': {
                        color: '#6b7280',
                        fontWeight: 500,
                        textTransform: 'none',
                        fontSize: '0.875rem',
                        '&.Mui-selected': {
                          color: '#005294',
                        },
                      },
                    }}
                  >
                    <Tab label="Quick Prediction" />
                    <Tab label="Dividend Growth Forecast" />
                    <Tab label="Investment Trend Predictor" />
                    <Tab label="Recent Results" />
                  </Tabs>
                  
                  {tabValue === 0 && (
                    <Box sx={{ mt: 3 }}>
                      <Box 
                        sx={{ 
                          display: 'flex',
                          flexDirection: { xs: 'column', md: 'row' },
                          gap: 2,
                          alignItems: 'flex-end'
                        }}
                      >
                        <Box sx={{ flex: 1 }}>
                          <Autocomplete
                            value={selectedStock}
                            onChange={(event, newValue) => {
                              setSelectedStock(newValue);
                              setSelectedSymbol(newValue?.symbol || '');
                            }}
                            inputValue={selectedSymbol}
                            onInputChange={(event, newInputValue, reason) => {
                              if (reason !== 'reset') {
                                setSelectedSymbol(newInputValue.toUpperCase());
                                searchStocks(newInputValue);
                              }
                            }}
                            options={stockOptions}
                            getOptionLabel={(option) => `${option.symbol} - ${option.name}`}
                            loading={stockSearchLoading}
                            renderInput={(params) => (
                              <TextField
                                {...params}
                                label="Stock Symbol"
                                placeholder="Search for stock (e.g., AAPL)"
                                size="small"
                                InputProps={{
                                  ...params.InputProps,
                                  endAdornment: (
                                    <React.Fragment>
                                      {stockSearchLoading ? <CircularProgress color="inherit" size={20} /> : null}
                                      {params.InputProps.endAdornment}
                                    </React.Fragment>
                                  ),
                                }}
                              />
                            )}
                            sx={{ width: '100%' }}
                            isOptionEqualToValue={(option, value) => option.symbol === value?.symbol}
                          />
                        </Box>
                        <Box sx={{ flex: 1 }}>
                          <FormControl fullWidth size="small">
                            <InputLabel>Prediction Timeframe</InputLabel>
                            <MuiSelect
                              value={predictionTimeframe}
                              label="Prediction Timeframe"
                              onChange={(e) => setPredictionTimeframe(e.target.value)}
                            >
                              <MenuItem value="3months">3 Months</MenuItem>
                              <MenuItem value="6months">6 Months</MenuItem>
                              <MenuItem value="12months">12 Months</MenuItem>
                              <MenuItem value="24months">24 Months</MenuItem>
                            </MuiSelect>
                          </FormControl>
                        </Box>
                        <Box sx={{ flex: 1 }}>
                          <MuiButton
                            variant="contained"
                            fullWidth
                            onClick={generatePrediction}
                            disabled={isGeneratingPrediction}
                            sx={{ 
                              backgroundColor: '#005294',
                              '&:hover': { backgroundColor: '#003d70' },
                              textTransform: 'none',
                              fontWeight: 500,
                              height: '40px'
                            }}
                          >
                            {isGeneratingPrediction ? 'Generating...' : 'Run Prediction'}
                          </MuiButton>
                        </Box>
                      </Box>
                      
                      {/* Display Current Prediction Result */}
                      {currentPrediction && (
                        <Box sx={{ mt: 4, p: 3, bgcolor: '#f8f9fa', borderRadius: 2, border: '1px solid #e0e0e0' }}>
                          <div className="space-y-3">
                            <div className="flex items-center justify-between">
                              <h3 className="text-lg font-semibold text-gray-900">Prediction Result</h3>
                              <Badge 
                                variant={currentPrediction.status === 'bullish' ? 'default' : 
                                        currentPrediction.status === 'bearish' ? 'destructive' : 'secondary'}
                                className="text-sm"
                              >
                                {currentPrediction.status?.toUpperCase()}
                              </Badge>
                            </div>
                            
                            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                              <div>
                                <p className="text-sm text-gray-600">Symbol</p>
                                <TickerBadge 
                                  symbol={currentPrediction.symbol}
                                  showAIButton={true}
                                  variant="secondary"
                                  size="sm"
                                />
                              </div>
                              
                              <div>
                                <p className="text-sm text-gray-600">Confidence</p>
                                <p className="text-xl font-bold text-gray-900">
                                  {currentPrediction.confidence}%
                                </p>
                              </div>
                              
                              <div>
                                <p className="text-sm text-gray-600">Timeframe</p>
                                <p className="text-lg font-medium text-gray-700">
                                  {currentPrediction.timeframe.replace('months', ' Months')}
                                </p>
                              </div>
                              
                              {currentPrediction.currentPrice && (
                                <div>
                                  <p className="text-sm text-gray-600">Current Price</p>
                                  <p className="text-lg font-medium text-gray-700">
                                    ${currentPrediction.currentPrice.toFixed(4)}
                                  </p>
                                </div>
                              )}
                            </div>
                            
                            <div className="pt-3 border-t border-gray-200">
                              <p className="text-sm text-gray-600 mb-1">Analysis</p>
                              <p className="text-gray-800">{currentPrediction.prediction}</p>
                            </div>
                            
                            <Button
                              onClick={() => setCurrentPrediction(null)}
                              variant="outline"
                              size="sm"
                              className="mt-2"
                            >
                              Clear Result
                            </Button>
                          </div>
                        </Box>
                      )}
                    </Box>
                  )}
                  
                  {tabValue === 1 && (
                    <Box sx={{ mt: 3 }}>
                      <PredictiveDividendGrowthForecaster />
                    </Box>
                  )}
                  
                  {tabValue === 2 && (
                    <Box sx={{ mt: 3 }}>
                      <AIInvestmentTrendPredictor />
                    </Box>
                  )}
                  
                  {tabValue === 3 && (
                    <Box sx={{ mt: 3 }}>
                      {predictionsLoading ? (
                        <div className="flex items-center justify-center py-8">
                          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary"></div>
                          <span className="ml-2">Loading predictions...</span>
                        </div>
                      ) : (
                        <div className="space-y-4">
                          {/* Display API predictions */}
                          {predictions.length > 0 ? predictions.map((item: PredictionData, index: number) => (
